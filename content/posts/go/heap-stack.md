---
title: "為什麼 Stack 分配比 Heap 分配更快"
categories: ["Go"]
---

### 1. 分配機制

#### Stack 分配

* **簡單的指針移動**：Stack 分配僅涉及移動 stack 指針。
* **預分配**：Stack 空間在程序啟動時就已預先分配。
* **LIFO 順序**：後進先出的特性使得分配和釋放非常快速。

#### Heap 分配

* **複雜的分配算法**：需要搜索合適的內存塊。
* **可能的碎片化**：可能需要合併空閒塊或處理內存碎片。
* **同步開銷**：在多線程環境中，需要同步機制以確保線程安全。

### 2. 內存佈局

#### Stack

* **連續性**：Stack 內存是連續的，提高了 CPU 快取效率。
* **局部性**：函數的局部變量在內存中彼此靠近，有利於快取命中。

#### Heap

* **分散性**：Heap 上的對象可能分散在內存的不同位置。
* **快取不友好**：對象之間的距離可能較遠，降低快取效率。

### 3. 生命週期管理

#### Stack

* **自動管理**：變量在函數返回時自動釋放。
* **無需額外開銷**：不需要跟蹤對象生命週期。

#### Heap

* **手動管理或垃圾回收**：需要手動釋放或依賴垃圾回收器。
* **額外開銷**：跟蹤對象生命週期，定期執行垃圾回收。

### 4. 線程安全

#### Stack

* **線程私有**：每個線程有自己的 stack，不需要同步。
* **無競爭**：不同線程的 stack 操作不會相互影響。

#### Heap

* **共享資源**：所有線程共享 heap 空間。
* **需要同步**：分配和釋放可能需要鎖或其他同步機制。

### 5. 大小限制

#### Stack

* **有限但快速**：大小通常較小（如幾 MB），但操作非常快。
* **大小可預測**：編譯時可以大致確定需求。

#### Heap

* **大小靈活**：可以動態增長，適合大型或不確定大小的對象。
* **管理複雜**：需要更複雜的管理機制。

### 結論

Stack 分配之所以比 Heap 分配快，主要是因為其簡單、預分配、自動管理的特性，以及更好的快取局部性。然而，Heap 分配提供了更大的靈活性，特別是對於大型對象或需要在函數調用之間共享的數據。

在實際編程中，了解這些差異有助於做出更好的設計決策，但現代編程語言（如 Go）的編譯器和運行時系統已經做了大量優化，在大多數情況下可以自動處理這些細節。