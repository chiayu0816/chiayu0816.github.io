---
title: "escape analysis"
categories: ["Go"]
---

### 定義

**逃逸分析是編譯器用來確定程式中的值是應該在 stack（堆疊）上分配還是在 heap（堆）上分配的一種技術。**

### 目的

1. 優化記憶體分配：盡可能地將變數分配在 stack 上，因為 stack 分配比 heap 分配更快。
2. 減少垃圾回收壓力：stack 上的記憶體不需要垃圾回收器處理。

### 工作原理

編譯器分析變數的生命週期和作用域，判斷變數是否會"逃逸"到其定義的函數之外。

#### 變數逃逸的情況：

1. 返回局部變數的指針
2. 閉包捕獲的變數
3. 大型結構體或數組
4. 動態大小的值（如部分 slice 或 map）
5. 接口類型的值

### 示例

#### 1. 返回局部變數的指針

```go
func createPointer() *int {
    x := 42
    return &x  // x 逃逸到 heap
}
```

#### 2. 不逃逸的情況

```go
func sum(a, b int) int {
    return a + b  // 所有變數都在 stack 上
}
```

### 如何查看逃逸分析結果

使用 `go build` 或 `go run` 時加上 `-gcflags=-m` 參數：

```
go run -gcflags=-m main.go
```

### 影響

1. 性能：stack 分配通常比 heap 分配快。
2. 垃圾回收：減少 heap 分配可以減輕 GC 壓力。
3. 程式設計：了解逃逸分析有助於寫出更高效的程式。

### 注意事項

1. 逃逸分析結果可能因 Go 版本而異。
2. 過度依賴逃逸分析可能導致程式難以理解。
3. 在大多數情況下，應該相信編譯器的判斷。

### 最佳實踐

1. 對於小型、短生命週期的對象，優先考慮值類型。
2. 對於需要修改的大型結構體，考慮使用指針。
3. 使用性能分析工具來識別關鍵的記憶體分配點。
4. 不要過早優化，先關注程式的正確性和可讀性。

理解逃逸分析有助於寫出更高效的 Go 程式，但也要記住，過度優化可能會影響程式的可讀性和維護性。在大多數情況下，Go 的自動記憶體管理已經足夠高效。